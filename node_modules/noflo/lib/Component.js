(function() {
  var Component, EventEmitter, IP, ProcessInput, ProcessOutput, ports,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  ports = require('./Ports');

  IP = require('./IP');

  Component = (function(_super) {
    __extends(Component, _super);

    Component.prototype.description = '';

    Component.prototype.icon = null;

    Component.prototype.started = false;

    Component.prototype.load = 0;

    Component.prototype.ordered = false;

    Component.prototype.outputQ = [];

    Component.prototype.activateOnInput = true;

    function Component(options) {
      this.error = __bind(this.error, this);
      if (!options) {
        options = {};
      }
      if (!options.inPorts) {
        options.inPorts = {};
      }
      if (options.inPorts instanceof ports.InPorts) {
        this.inPorts = options.inPorts;
      } else {
        this.inPorts = new ports.InPorts(options.inPorts);
      }
      if (!options.outPorts) {
        options.outPorts = {};
      }
      if (options.outPorts instanceof ports.OutPorts) {
        this.outPorts = options.outPorts;
      } else {
        this.outPorts = new ports.OutPorts(options.outPorts);
      }
      if (options.icon) {
        this.icon = options.icon;
      }
      if (options.description) {
        this.description = options.description;
      }
      if ('ordered' in options) {
        this.ordered = options.ordered;
      }
      if ('activateOnInput' in options) {
        this.activateOnInput = options.activateOnInput;
      }
      if (typeof options.process === 'function') {
        this.process(options.process);
      }
    }

    Component.prototype.getDescription = function() {
      return this.description;
    };

    Component.prototype.isReady = function() {
      return true;
    };

    Component.prototype.isSubgraph = function() {
      return false;
    };

    Component.prototype.setIcon = function(icon) {
      this.icon = icon;
      return this.emit('icon', this.icon);
    };

    Component.prototype.getIcon = function() {
      return this.icon;
    };

    Component.prototype.error = function(e, groups, errorPort) {
      var group, _i, _j, _len, _len1;
      if (groups == null) {
        groups = [];
      }
      if (errorPort == null) {
        errorPort = 'error';
      }
      if (this.outPorts[errorPort] && (this.outPorts[errorPort].isAttached() || !this.outPorts[errorPort].isRequired())) {
        for (_i = 0, _len = groups.length; _i < _len; _i++) {
          group = groups[_i];
          this.outPorts[errorPort].beginGroup(group);
        }
        this.outPorts[errorPort].send(e);
        for (_j = 0, _len1 = groups.length; _j < _len1; _j++) {
          group = groups[_j];
          this.outPorts[errorPort].endGroup();
        }
        this.outPorts[errorPort].disconnect();
        return;
      }
      throw e;
    };

    Component.prototype.shutdown = function() {
      return this.started = false;
    };

    Component.prototype.start = function() {
      this.started = true;
      return this.started;
    };

    Component.prototype.isStarted = function() {
      return this.started;
    };

    Component.prototype.process = function(handle) {
      var name, port, _ref;
      if (typeof handle !== 'function') {
        throw new Error("Process handler must be a function");
      }
      if (!this.inPorts) {
        throw new Error("Component ports must be defined before process function");
      }
      this.handle = handle;
      _ref = this.inPorts.ports;
      for (name in _ref) {
        port = _ref[name];
        if (!port.name) {
          port.name = name;
        }
        port.on('ip', (function(_this) {
          return function(ip) {
            return _this.handleIP(ip, port);
          };
        })(this));
      }
      return this;
    };

    Component.prototype.handleIP = function(ip, port) {
      var input, output, result;
      if (!port.options.triggering) {
        return;
      }
      result = {};
      input = new ProcessInput(this.inPorts, ip, this, port, result);
      output = new ProcessOutput(this.outPorts, ip, this, result);
      this.load++;
      return this.handle(input, output, function() {
        return output.done();
      });
    };

    return Component;

  })(EventEmitter);

  exports.Component = Component;

  ProcessInput = (function() {
    function ProcessInput(ports, ip, nodeInstance, port, result) {
      this.ports = ports;
      this.ip = ip;
      this.nodeInstance = nodeInstance;
      this.port = port;
      this.result = result;
      this.scope = this.ip.scope;
    }

    ProcessInput.prototype.activate = function() {
      this.result.__resolved = false;
      if (this.nodeInstance.ordered) {
        return this.nodeInstance.outputQ.push(this.result);
      }
    };

    ProcessInput.prototype.has = function() {
      var port, res, _i, _len;
      res = true;
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        port = arguments[_i];
        res && (res = this.ports[port].ready(this.scope));
      }
      return res;
    };

    ProcessInput.prototype.get = function() {
      var port, res;
      if (this.nodeInstance.ordered && this.nodeInstance.activateOnInput && !('__resolved' in this.result)) {
        this.activate();
      }
      res = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          port = arguments[_i];
          _results.push(this.ports[port].get(this.scope));
        }
        return _results;
      }).apply(this, arguments);
      if (arguments.length === 1) {
        return res[0];
      } else {
        return res;
      }
    };

    ProcessInput.prototype.getData = function() {
      var ip, ips, _i, _len, _results;
      ips = this.get.apply(this, arguments);
      if (arguments.length === 1) {
        return ips.data;
      }
      _results = [];
      for (_i = 0, _len = ips.length; _i < _len; _i++) {
        ip = ips[_i];
        _results.push(ip.data);
      }
      return _results;
    };

    return ProcessInput;

  })();

  ProcessOutput = (function() {
    function ProcessOutput(ports, ip, nodeInstance, result) {
      this.ports = ports;
      this.ip = ip;
      this.nodeInstance = nodeInstance;
      this.result = result;
      this.scope = this.ip.scope;
    }

    ProcessOutput.prototype.activate = function() {
      this.result.__resolved = false;
      if (this.nodeInstance.ordered) {
        return this.nodeInstance.outputQ.push(this.result);
      }
    };

    ProcessOutput.prototype.isError = function(err) {
      return err instanceof Error || Array.isArray(err) && err.length > 0 && err[0] instanceof Error;
    };

    ProcessOutput.prototype.error = function(err) {
      var e, multiple, _i, _j, _len, _len1, _results;
      multiple = Array.isArray(err);
      if (!multiple) {
        err = [err];
      }
      if ('error' in this.ports && (this.ports.error.isAttached() || !this.ports.error.isRequired())) {
        if (multiple) {
          this.sendIP('error', new IP('openBracket'));
        }
        for (_i = 0, _len = err.length; _i < _len; _i++) {
          e = err[_i];
          this.sendIP('error', e);
        }
        if (multiple) {
          return this.sendIP('error', new IP('closeBracket'));
        }
      } else {
        _results = [];
        for (_j = 0, _len1 = err.length; _j < _len1; _j++) {
          e = err[_j];
          throw e;
        }
        return _results;
      }
    };

    ProcessOutput.prototype.sendIP = function(port, packet) {
      var ip;
      if (typeof packet !== 'object' || IP.types.indexOf(packet.type) === -1) {
        ip = new IP('data', packet);
      } else {
        ip = packet;
      }
      if (this.scope !== null && ip.scope === null) {
        ip.scope = this.scope;
      }
      if (this.nodeInstance.ordered) {
        if (!(port in this.result)) {
          this.result[port] = [];
        }
        return this.result[port].push(ip);
      } else {
        return this.nodeInstance.outPorts[port].sendIP(ip);
      }
    };

    ProcessOutput.prototype.send = function(outputMap) {
      var packet, port, _results;
      if (this.nodeInstance.ordered && !('__resolved' in this.result)) {
        this.activate();
      }
      if (this.isError(outputMap)) {
        return this.error(outputMap);
      }
      _results = [];
      for (port in outputMap) {
        packet = outputMap[port];
        _results.push(this.sendIP(port, packet));
      }
      return _results;
    };

    ProcessOutput.prototype.sendDone = function(outputMap) {
      this.send(outputMap);
      return this.done();
    };

    ProcessOutput.prototype.done = function(error) {
      var ip, ips, port, result, _i, _len;
      if (error) {
        this.error(error);
      }
      if (this.nodeInstance.ordered) {
        this.result.__resolved = true;
        while (this.nodeInstance.outputQ.length > 0) {
          result = this.nodeInstance.outputQ[0];
          if (!result.__resolved) {
            break;
          }
          for (port in result) {
            ips = result[port];
            if (port === '__resolved') {
              continue;
            }
            for (_i = 0, _len = ips.length; _i < _len; _i++) {
              ip = ips[_i];
              this.nodeInstance.outPorts[port].sendIP(ip);
            }
          }
          this.nodeInstance.outputQ.shift();
        }
      }
      return this.nodeInstance.load--;
    };

    return ProcessOutput;

  })();

}).call(this);
